Index: plugins/src/sound.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>#include <stdio.h>\n#include <stdlib.h>\n#include <pulse/pulseaudio.h>\n\nstatic int volume_retrieved = 0;  // Indicateur pour arrêter après un seul affichage\n\n// Callback pour surveiller l'état du contexte\nstatic void context_state_cb(pa_context *context, void *userdata) {\n    pa_context_state_t state = pa_context_get_state(context);\n    if (state == PA_CONTEXT_READY || state == PA_CONTEXT_FAILED || state == PA_CONTEXT_TERMINATED) {\n        *(int *)userdata = 1;\n    }\n}\n\n// Callback pour afficher le volume\nstatic void sink_info_cb(pa_context *context, const pa_sink_info *info, int eol, void *userdata) {\n    (void) context;\n    (void) userdata;\n    if (eol > 0 || !info || volume_retrieved) {\n        return;\n    }\n\n    // Calculer le pourcentage de volume\n    int volume_percent = (int)(pa_cvolume_avg(&info->volume) * 100 / PA_VOLUME_NORM);\n    printf(\"Volume actuel : %d%%\\n\", volume_percent);\n\n    volume_retrieved = 1;  // Marquer comme récupéré\n}\n\nvoid get_pulseaudio_volume_once() {\n    pa_mainloop *mainloop = pa_mainloop_new();\n    pa_mainloop_api *mainloop_api = pa_mainloop_get_api(mainloop);\n    pa_context *context = pa_context_new(mainloop_api, \"Volume Getter\");\n\n    int ready = 0;\n    pa_context_set_state_callback(context, context_state_cb, &ready);\n    pa_context_connect(context, NULL, PA_CONTEXT_NOFLAGS, NULL);\n\n    // Attendre que le contexte soit prêt\n    while (ready == 0) {\n        pa_mainloop_iterate(mainloop, 1, NULL);\n    }\n\n    if (pa_context_get_state(context) != PA_CONTEXT_READY) {\n        fprintf(stderr, \"Impossible de se connecter à PulseAudio\\n\");\n        pa_context_disconnect(context);\n        pa_context_unref(context);\n        pa_mainloop_free(mainloop);\n        return;\n    }\n\n    // Récupérer les informations sur les sinks\n    pa_operation *op = pa_context_get_sink_info_list(context, sink_info_cb, NULL);\n    while (pa_operation_get_state(op) == PA_OPERATION_RUNNING && !volume_retrieved) {\n        pa_mainloop_iterate(mainloop, 1, NULL);\n    }\n    pa_operation_unref(op);\n\n    // Nettoyage\n    pa_context_disconnect(context);\n    pa_context_unref(context);\n    pa_mainloop_free(mainloop);\n}\n\nint main() {\n    get_pulseaudio_volume_once();\n    return 0;\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/plugins/src/sound.c b/plugins/src/sound.c
--- a/plugins/src/sound.c	(revision c33bdce796f08176661ad3e5e55f1d4be186eccd)
+++ b/plugins/src/sound.c	(date 1736097415405)
@@ -1,8 +1,29 @@
 #include <stdio.h>
 #include <stdlib.h>
+#include <string.h>
 #include <pulse/pulseaudio.h>
+#include <stdbool.h>
+#include <math.h>
+
+#define FORMAT_VOLUME "%percentage%%"
+#define FORMAT_MUTED "%percentage%% Muted"
+#define PA_DECIBEL_MININFTY -100
 
-static int volume_retrieved = 0;  // Indicateur pour arrêter après un seul affichage
+typedef struct {
+    char *sink_name;
+    float volume;
+    float decibels;
+    bool muted;
+    bool reverse_scroll;
+    bool unmute_on_scroll;
+    int interval;
+    pa_context *context;
+    pa_mainloop *mainloop;
+    pa_operation *operation;
+} pulseaudio_module_t;
+
+// Déclaration de la fonction callback
+static void context_state_cb(pa_context *context, void *userdata);
 
 // Callback pour surveiller l'état du contexte
 static void context_state_cb(pa_context *context, void *userdata) {
@@ -12,57 +33,88 @@
     }
 }
 
-// Callback pour afficher le volume
+// Callback pour afficher les informations du sink
 static void sink_info_cb(pa_context *context, const pa_sink_info *info, int eol, void *userdata) {
-    (void) context;
-    (void) userdata;
-    if (eol > 0 || !info || volume_retrieved) {
+    pulseaudio_module_t *module = (pulseaudio_module_t *)userdata;
+
+    if (eol > 0 || !info || module->muted) {
         return;
     }
 
-    // Calculer le pourcentage de volume
-    int volume_percent = (int)(pa_cvolume_avg(&info->volume) * 100 / PA_VOLUME_NORM);
-    printf("Volume actuel : %d%%\n", volume_percent);
+    // Calculer le volume en pourcentage
+    module->volume = (float)(pa_cvolume_avg(&info->volume) * 100) / PA_VOLUME_NORM;
+    module->muted = info->mute;
 
-    volume_retrieved = 1;  // Marquer comme récupéré
+    printf("Volume actuel : %.2f%%\n", module->volume);
+    if (module->muted) {
+        printf("Muted\n");
+    }
 }
-
-void get_pulseaudio_volume_once() {
-    pa_mainloop *mainloop = pa_mainloop_new();
-    pa_mainloop_api *mainloop_api = pa_mainloop_get_api(mainloop);
-    pa_context *context = pa_context_new(mainloop_api, "Volume Getter");
 
+// Fonction pour initialiser et récupérer le volume PulseAudio
+void get_pulseaudio_volume_once(pulseaudio_module_t *module) {
     int ready = 0;
-    pa_context_set_state_callback(context, context_state_cb, &ready);
-    pa_context_connect(context, NULL, PA_CONTEXT_NOFLAGS, NULL);
+    module->mainloop = pa_mainloop_new();
+    pa_mainloop_api *mainloop_api = pa_mainloop_get_api(module->mainloop);
+    module->context = pa_context_new(mainloop_api, "Volume Getter");
+
+    pa_context_set_state_callback(module->context, context_state_cb, &ready);
+    pa_context_connect(module->context, NULL, PA_CONTEXT_NOFLAGS, NULL);
 
     // Attendre que le contexte soit prêt
     while (ready == 0) {
-        pa_mainloop_iterate(mainloop, 1, NULL);
+        pa_mainloop_iterate(module->mainloop, 1, NULL);
     }
 
-    if (pa_context_get_state(context) != PA_CONTEXT_READY) {
+    if (pa_context_get_state(module->context) != PA_CONTEXT_READY) {
         fprintf(stderr, "Impossible de se connecter à PulseAudio\n");
-        pa_context_disconnect(context);
-        pa_context_unref(context);
-        pa_mainloop_free(mainloop);
+        pa_context_disconnect(module->context);
+        pa_context_unref(module->context);
+        pa_mainloop_free(module->mainloop);
         return;
     }
 
-    // Récupérer les informations sur les sinks
-    pa_operation *op = pa_context_get_sink_info_list(context, sink_info_cb, NULL);
-    while (pa_operation_get_state(op) == PA_OPERATION_RUNNING && !volume_retrieved) {
-        pa_mainloop_iterate(mainloop, 1, NULL);
+    // Récupérer les informations du sink
+    module->operation = pa_context_get_sink_info_list(module->context, sink_info_cb, module);
+    while (pa_operation_get_state(module->operation) == PA_OPERATION_RUNNING) {
+        pa_mainloop_iterate(module->mainloop, 1, NULL);
     }
-    pa_operation_unref(op);
+    pa_operation_unref(module->operation);
 
     // Nettoyage
-    pa_context_disconnect(context);
-    pa_context_unref(context);
-    pa_mainloop_free(mainloop);
+    pa_context_disconnect(module->context);
+    pa_context_unref(module->context);
+    pa_mainloop_free(module->mainloop);
+}
+
+// Afficher le volume actuel en pourcentage
+void print_current_volume(pulseaudio_module_t *module) {
+    printf("Volume actuel : %.2f%%\n", module->volume);
+}
+
+// Initialisation du module
+void pulseaudio_module_init(pulseaudio_module_t *module, const char *sink_name, int interval, bool unmute_on_scroll, bool reverse_scroll) {
+    module->sink_name = strdup(sink_name);
+    module->volume = 50.0f;
+    module->decibels = PA_DECIBEL_MININFTY;
+    module->muted = false;
+    module->interval = interval;
+    module->unmute_on_scroll = unmute_on_scroll;
+    module->reverse_scroll = reverse_scroll;
+}
+
+// Libération de la mémoire
+void pulseaudio_module_free(pulseaudio_module_t *module) {
+    free(module->sink_name);
 }
 
 int main() {
-    get_pulseaudio_volume_once();
+    pulseaudio_module_t module;
+    pulseaudio_module_init(&module, "default", 5, true, false);
+
+    get_pulseaudio_volume_once(&module);
+    print_current_volume(&module);
+
+    pulseaudio_module_free(&module);
     return 0;
 }
